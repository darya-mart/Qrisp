.. _CircuitManipulation:

Circuit Manipulation
====================

The circuit manipulation module allows the user to export Qrisp algorithms to the QuantumCircuit format and convert them to other libraries such as Qiskit. Furthermore it is possible to integrate low-level functions into the high-level infrastructure. For classical languages, this is a `common feature <https://en.wikipedia.org/wiki/Inline_assembler>`_ of many compilers. 
Since :ref:`QuantumSession` is an inheritor of QuantumCircuit, it also exposes an append method, implying that once a QuantumCircuit is created it can be smoothly integrated into Qrisps high-level infrastructure using the :meth:`to_gate <qrisp.QuantumCircuit.to_gate>` method:

::
   
   from qrisp import QuantumCircuit
   from third_party_qiskit_module import some_quantum_function_qc
   
   def some_quantum_function(qv, parameters):
      qc = QuantumCircuit.from_qiskit(some_quantum_function_qc(parameters))
      qv.qs.append(qc.to_gate(), qv)
   

This snippet demonstrates how a Qiskit quantum circuit generated by a third party module can be turned into a Qrisp function of a :ref:`QuantumVariable`.

There are 5 important classes here:

* The :doc:`QuantumCircuit` class, which describes quantum circuits in a very similar way as Qiskit (ie. it contains a list of qubit objects, a list of classical bit objects and a list of instructions)

* The :doc:`Operation` class, which corresponds to the gate object from Qiskit. This class describes arbitrary gates and measurements.

* The :doc:`Instruction` class, which combines Operation objects and the qubit/classical bits it operates on.

* The :doc:`Qubit` class, which represents qubits.

* The :doc:`Clbit` class, which represents classical bits.

.. note::
   In order to allow an easy transition, this module's architecture and naming is close to Qiskit.

.. toctree::
   :maxdepth: 2
   :hidden:
   
   QuantumCircuit
   Operation
   Instruction
   Qubit
   Clbit